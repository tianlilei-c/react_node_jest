## 作业任务

在这个任务中，你将交付你的完全集成的（前端连接到后端的）多用户网络应用程序。目标是：

- 实现 API 中的所有端点。不应该有任何存根（stubs）。
- 根据用户关注的用户，生成一个统一的文章流。
- 允许用户上传带有图片的文章。
- 添加第三方认证选项（与账户链接）。
- 添加分页。

我们的前端网络应用程序中剩下的实现功能是上传文章（有无图片均可），添加评论，编辑文章和评论，以及通过上传新的个人资料头像来编辑用户的个人资料。

## 用户的 Feed

每个登录用户都有一个 feed，其中包括他们自己的文章以及他们关注者的文章。当用户请求 GET `/articles` 时，我们需要返回这个联合的集合。一个差的算法如下所示：

```javascript
const userObj = getUser(req.user)
const articles = [userObj.username,
  ...userObj.following].reduce((o, user) => 
    o.concat(getArticlesByAuthor(user)), [])
```

这样做不好，因为它会把所有时间的所有文章加到结果集（articles）中，并且额外对数据库进行多次请求。相反，我们要一个查询来从数据库检索所有用户的文章，并且只显示那些最新的文章。我们可以做的像这样：

```javascript
const userObj = getUser(req.user)
const usersToQuery = [userObj.username, ...userObj.following]
const articles = Article.find({ author: { $in: usersToQuery }, limit: 10 })
```

其中查询将会抓取数组中所有用户的最近 10 篇文章。但是，我们将会获取所有文章并使用分页来只展示每次 10 篇文章。这样客户端将会一次性只发送一个请求来获取用户的 feed，并且每一页将会相对较小。你需要查看 MongoDB/mongoose 文档，并且只写一个查询到数据库，并且只返回需要的数据。文章的排序（最新的在前）可以由 MongoDB（更好）或者服务器端（不是很好）完成。

## 持久化图片上传

当我们将一张图片上传到服务器时，它将被存储在磁盘上。这可能会占用大量的磁盘空间，如果我们不小心限制用户上传等。此外，在Heroku上的本地存储在dyno重启后是不持久的，也就是说，在你重新部署代码后，Heroku dyno将会重启，并且任何本地上传的文件在新的dyno上将不会可用。因此，存储图片的方式并不理想。

MongoDB有一个文档限制大小为16 MB。这意味着对于大多数上传，我们可能可以将它们作为文档存储在MongoDB中。但是，对于图片来说这不方便，因为我们的后端服务器首先必须从MongoDB中拉取文档，然后再将图片发送到前端。如果图片可以直接从数据存储中被前端拉取会更好。

我们可以使用亚马逊的S3来存储大量数据，比如图片。S3是一个很好的服务，实际上Heroku就是使用S3的，但是在免费试用期外，S3并不是免费的。相反，我们将使用Cloudinary，它有一个免费层次，来持久化存储上传的图片。

我们需要一些模块：Multer是一个用于处理 `multipart/form-data` 的 node.js 中间件，这正是我们用来上传文件的。

```bash
npm install cloudinary multer --save
heroku addons:create cloudinary:starter-2
heroku config
```

为了在Heroku上使用Cloudinary可能需要计费信息 -- 如果你留在免费层次，你不会被收费。如果你不能通过Heroku插件让Cloudinary工作，你可以直接去他们的网站注册。我们需要的Cloudinary的url，就是最后一行命令提供的。

## 下载 Cloudinary 入门套件

遵循即将在课堂上展示的入门套件。然后根据功能演示来实现功能。然后用你的前端实现 PUT `/avatar` 端点，并验证它是否有效。你还需要实现添加带有文本和图片的文章。你将使用相同的中间件 `uploadImage` 来进行上传。

## 第三方认证

按照课堂上的练习，在应用中增加第三方认证选项。你可以选择与哪个第三方进行合作。无论是 Twitter、Facebook、Google 还是任何 OAuth 或 OAuth2 提供商都可以。你应该使用 Request（OAuth）或 PassportJS（OAuth 或 OAuth2）作为认证的中间件。

在你的登录页面旁边的注册和登录按钮，应该增加一个额外的按钮，以便用户可以通过第三方登录。当用户通过这种方式登录时，他们的账户会被链接到我们的系统中。你可以尝试通过用户的电子邮件地址或通过用户名+第三方来查找用户，以此方式区分普通密码登录的用户和第三方认证用户。因此，我们需要更新我们的用户模型来捕获这些信息。当用户使用第三方认证登录时，如果我们的数据库中没有他们的记录（即，通过电子邮件或通过用户名+第三方），那么就创建一个新记录在文档存储中，没有密码，但是有一个用户名和一个第三方的标识符。例如，用户名为“mrj1”并且没有“rice”后缀，这表明这是 Rice OAuth 服务为 netid mrj1 提供的服务。注意我们现在可能会在用户名“mrj1”注册了一个带密码的账户和“mrj1”使用 OAuth 的用户名之间产生冲突。我们可能希望这些账户可以合并？但是确认用户信息可能会有问题（如果使用 OAuth 的 mrj1@rice 用户并不拥有我们站点上的 mrj1 用户呢？）。因此，我们可能需要以某种方式来唯一标识用户，以防止用户名冲突，并且用户可以像普通用户一样使用我们的网站进行第三方认证登录。

## 账户链接（COMP 531 仅限）

但是这些账户可能属于同一个用户？

在你的个人资料页面，为用户提供一个方法来将他们的账户链接起来。例如，在个人资料页面上会有一个“链接账户”按钮，如果用户使用第三方登录，他们将能够使用用户名和密码登录我们的网站。如果他们第二次登录我们的网站，那么将直接将他们导向第三方登录。在用户第二次登录后，我们需要合并这两个账户。这意味着我们需要搜索以查看是否已经有了第二个用户记录并删除它（例如，如果用户作为 mrj1@rice 登录，然后作为 mrj1 但想要链接账户，那么你将删除 mrj1@rice 记录，并合并以下用户记录）。对于 mrj1 记录，你将添加额外的认证信息，可能这个字段会是 `auth: { rice: mrj1, google: mrj2, facebook: markJ }`，以便我可以链接多个第三方账户。稍后当用户使用第三方登录时，我们需要一个 MongoDB 查询来搜索这个新的 auth 字段以添加认证信息。

如果我们可以链接账户，那么我们也应该允许用户解除链接账户，这应该是直接的。在这种情况下，我们只会删除 OAuth 账户，我们不会为它生成一个新的 User 记录，例如，如果我取消了 my@rice 的 OAuth 账户，结果将是：`{ google: mrj2, facebook: markJ }` 但不是 mrj1@rice User 记录。

提示：完成作业的其他部分后，再开始处理账户链接。

翻译如下：

## 要求

- 所有端点都已完全实现。没有存根。
- 用户 feed 包括来自登录用户及其关注者的文章。
- 用户可以对文章添加评论。
- 用户可以编辑文章和评论。
- 用户可以更新他们的个人头像。
- 用户可以创建包含图片和文本的文章。
- 分页。
- 所有数据在服务器重启后仍然持久。
- 第三方认证登录。
- 第三方认证账户链接和解除链接（COMP 531 仅限，选择链接顺序）。

你的提交应包括你最终的前端和后端应用程序，以及你的 README.md 文件，其中包含指向你的 Surge 和 Heroku 托管站点的 URL。你还应该在 README.md 文件中包含一个用户名和密码，以便登录你的网络应用程序。这是你的最终提交，所以所有东西都应该能够“开箱即用”。

你的提交目录将类似于之前作业的目录。

翻译如下：

## 评分点 [100]

- `README.md` 文件包含用户名、密码、前端和后端的 URLs [2]
- 所有后端功能都如之前的作业一样存在 [10]
- 前端：用户界面和样式 [10]
- 前端：功能齐全，如之前作业 [10]
- 用户的 feed 由一个高效的 MongoDB 查询提供 [10]
- 用户可以使用第三方认证登录（并链接账户 - COMP 531 仅限）[15]
- 会话从 cookie 中存储/检索 [5]
- 编辑文章和评论 [5]
- 发布包含文本和图片的文章 [5]
- 更新个人头像 [5]
- 上传的图片在服务器重启后仍持久化，即使用 Cloudinary [8]
- 分页 [5]
- 所有后端端点都实现了 [10]

## 扣分点 [20]

- 前端没有使用 angular 或 react 框架 [-5]
- 使用了未批准的第三方模块 [-5]
- 当页面刷新时，应保持用户登录状态 [-2]
- 出现错误 [-3]
- 控制台消息遗留 [-3]

**总计 [100]**